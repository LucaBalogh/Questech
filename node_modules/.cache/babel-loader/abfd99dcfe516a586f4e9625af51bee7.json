{"ast":null,"code":"import { __spreadArrays } from \"tslib\";\nimport { find, isElementVisibleAndNotHidden, values } from '../../Utilities';\nimport { ktpTargetFromSequences, mergeOverflows, sequencesToID } from '../../utilities/keytips/KeytipUtils';\nimport { KTP_LAYER_ID } from '../../utilities/keytips/KeytipConstants';\n/**\r\n * This class is responsible for handling the parent/child relationships between keytips\r\n */\n\nvar KeytipTree =\n/** @class */\nfunction () {\n  /**\r\n   * KeytipTree constructor\r\n   */\n  function KeytipTree() {\n    this.nodeMap = {}; // Root has no keytipSequence\n\n    this.root = {\n      id: KTP_LAYER_ID,\n      children: [],\n      parent: '',\n      keySequences: []\n    };\n    this.nodeMap[this.root.id] = this.root;\n  }\n  /**\r\n   * Add a keytip node to this KeytipTree\r\n   *\r\n   * @param keytipProps - Keytip to add to the Tree\r\n   * @param uniqueID - Unique ID for this keytip\r\n   * @param persisted - T/F if this keytip should be marked as persisted\r\n   */\n\n\n  KeytipTree.prototype.addNode = function (keytipProps, uniqueID, persisted) {\n    var fullSequence = this._getFullSequence(keytipProps);\n\n    var nodeID = sequencesToID(fullSequence); // Take off the last item to calculate the parent sequence\n\n    fullSequence.pop(); // Parent ID is the root if there aren't any more sequences\n\n    var parentID = this._getParentID(fullSequence); // Create node and add to map\n\n\n    var node = this._createNode(nodeID, parentID, [], keytipProps, persisted);\n\n    this.nodeMap[uniqueID] = node; // Try to add self to parents children\n\n    var parents = this.getNodes([parentID]);\n    parents.forEach(function (parent) {\n      return parent.children.push(nodeID);\n    });\n  };\n  /**\r\n   * Updates a node in the tree\r\n   *\r\n   * @param keytipProps - Keytip props to update\r\n   * @param uniqueID - Unique ID for this keytip\r\n   */\n\n\n  KeytipTree.prototype.updateNode = function (keytipProps, uniqueID) {\n    var fullSequence = this._getFullSequence(keytipProps);\n\n    var nodeID = sequencesToID(fullSequence); // Take off the last item to calculate the parent sequence\n\n    fullSequence.pop(); // Parent ID is the root if there aren't any more sequences\n\n    var parentID = this._getParentID(fullSequence);\n\n    var node = this.nodeMap[uniqueID];\n    var prevParent = node.parent;\n\n    if (node) {\n      // Fix parent nodes if needed\n      if (prevParent !== parentID) {\n        // If parent has changed, remove child from old parent\n        this._removeChildFromParents(prevParent, node.id);\n      }\n\n      if (node.id !== nodeID) {\n        // If the ID of the node has changed, update node's parent's array of children with new ID\n        var parents = this.getNodes([parentID]);\n        parents.forEach(function (parent) {\n          var index = parent.children.indexOf(node.id);\n          index >= 0 ? parent.children[index] = nodeID : parent.children.push(nodeID);\n        });\n      } // Update values\n\n\n      node.id = nodeID;\n      node.keySequences = keytipProps.keySequences;\n      node.overflowSetSequence = keytipProps.overflowSetSequence;\n      node.onExecute = keytipProps.onExecute;\n      node.onReturn = keytipProps.onReturn;\n      node.hasDynamicChildren = keytipProps.hasDynamicChildren;\n      node.hasMenu = keytipProps.hasMenu;\n      node.parent = parentID;\n      node.disabled = keytipProps.disabled;\n    }\n  };\n  /**\r\n   * Removes a node from the KeytipTree\r\n   *\r\n   * @param sequence - full string of the node to remove\r\n   */\n\n\n  KeytipTree.prototype.removeNode = function (keytipProps, uniqueID) {\n    var fullSequence = this._getFullSequence(keytipProps);\n\n    var nodeID = sequencesToID(fullSequence); // Take off the last sequence to calculate the parent ID\n\n    fullSequence.pop(); // Parent ID is the root if there aren't any more sequences\n\n    this._removeChildFromParents(this._getParentID(fullSequence), nodeID);\n\n    if (this.nodeMap[uniqueID]) {\n      // Remove the node from the nodeMap\n      delete this.nodeMap[uniqueID];\n    }\n  };\n  /**\r\n   * Searches the currentKeytip's children to exactly match a sequence. Will not match disabled nodes but\r\n   * will match persisted nodes\r\n   *\r\n   * @param keySequence - string to match\r\n   * @param currentKeytip - The keytip whose children will try to match\r\n   * @returns The node that exactly matched the keySequence, or undefined if none matched\r\n   */\n\n\n  KeytipTree.prototype.getExactMatchedNode = function (keySequence, currentKeytip) {\n    var _this = this;\n\n    var possibleNodes = this.getNodes(currentKeytip.children);\n    var matchingNodes = possibleNodes.filter(function (node) {\n      return _this._getNodeSequence(node) === keySequence && !node.disabled;\n    }); // If we found no nodes, we are done\n\n    if (matchingNodes.length === 0) {\n      return undefined;\n    } // Since the matching nodes all have the same key sequence,\n    // Grab the first one build the correct selector\n\n\n    var node = matchingNodes[0]; // If we have exactly one node, return it\n\n    if (matchingNodes.length === 1) {\n      return node;\n    } // Get the potential target elements based on a selector from the sequences\n\n\n    var keySequences = node.keySequences;\n    var overflowSetSequence = node.overflowSetSequence;\n    var fullKeySequences = overflowSetSequence ? mergeOverflows(keySequences, overflowSetSequence) : keySequences;\n    var keytipTargetSelector = ktpTargetFromSequences(fullKeySequences);\n    var potentialTargetElements = document.querySelectorAll(keytipTargetSelector); // If we have less nodes than the potential target elements,\n    // we won't be able to map element to node, return the first node.\n    // Note, the number of nodes could be more than the number of potential\n    // target elements, if an OverflowSet is involved\n\n    if (matchingNodes.length < potentialTargetElements.length) {\n      return node;\n    } // Attempt to find the node that corresponds to the first visible/non-hidden element\n\n\n    var matchingIndex = Array.from(potentialTargetElements).findIndex(function (element) {\n      return isElementVisibleAndNotHidden(element);\n    });\n\n    if (matchingIndex !== -1) {\n      return matchingNodes[matchingIndex];\n    } // We did not find any visible elements associated with any of the nodes.\n    // We may be dealing with a keytip that is a submenu in an OverflowSet.\n    // Worst case, fall back to the first node returned\n\n\n    var overflowNode = matchingNodes.find(function (matchingNode) {\n      return matchingNode.hasOverflowSubMenu;\n    });\n    return overflowNode || node;\n  };\n  /**\r\n   * Searches the currentKeytip's children to find nodes that start with the given sequence. Will not match\r\n   * disabled nodes but will match persisted nodes\r\n   *\r\n   * @param keySequence - string to partially match\r\n   * @param currentKeytip - The keytip whose children will try to partially match\r\n   * @returns List of tree nodes that partially match the given sequence\r\n   */\n\n\n  KeytipTree.prototype.getPartiallyMatchedNodes = function (keySequence, currentKeytip) {\n    var _this = this; // Get children that are persisted\n\n\n    var possibleNodes = this.getNodes(currentKeytip.children);\n    return possibleNodes.filter(function (node) {\n      return _this._getNodeSequence(node).indexOf(keySequence) === 0 && !node.disabled;\n    });\n  };\n  /**\r\n   * Get the non-persisted children of the give node\r\n   * If no node is given, will use the 'currentKeytip'\r\n   *\r\n   * @param node - Node to get the children for\r\n   * @returns List of node IDs that are the children of the node\r\n   */\n\n\n  KeytipTree.prototype.getChildren = function (node) {\n    var _this = this;\n\n    if (!node) {\n      node = this.currentKeytip;\n\n      if (!node) {\n        return [];\n      }\n    }\n\n    var children = node.children;\n    return Object.keys(this.nodeMap).reduce(function (nodes, key) {\n      if (children.indexOf(_this.nodeMap[key].id) >= 0 && !_this.nodeMap[key].persisted) {\n        nodes.push(_this.nodeMap[key].id);\n      }\n\n      return nodes;\n    }, []);\n  };\n  /**\r\n   * Gets all nodes from their IDs\r\n   *\r\n   * @param ids - List of keytip IDs\r\n   * @returns Array of nodes that match the given IDs, can be empty\r\n   */\n\n\n  KeytipTree.prototype.getNodes = function (ids) {\n    var _this = this;\n\n    return Object.keys(this.nodeMap).reduce(function (nodes, key) {\n      if (ids.indexOf(_this.nodeMap[key].id) >= 0) {\n        nodes.push(_this.nodeMap[key]);\n      }\n\n      return nodes;\n    }, []);\n  };\n  /**\r\n   * Gets a single node from its ID\r\n   *\r\n   * @param id - ID of the node to get\r\n   * @returns Node with the given ID, if found\r\n   */\n\n\n  KeytipTree.prototype.getNode = function (id) {\n    var nodeMapValues = values(this.nodeMap);\n    return find(nodeMapValues, function (node) {\n      return node.id === id;\n    });\n  };\n  /**\r\n   * Tests if the currentKeytip in this.keytipTree is the parent of 'keytipProps'\r\n   *\r\n   * @param keytipProps - Keytip to test the parent for\r\n   * @returns T/F if the currentKeytip is this keytipProps' parent\r\n   */\n\n\n  KeytipTree.prototype.isCurrentKeytipParent = function (keytipProps) {\n    if (this.currentKeytip) {\n      var fullSequence = __spreadArrays(keytipProps.keySequences);\n\n      if (keytipProps.overflowSetSequence) {\n        fullSequence = mergeOverflows(fullSequence, keytipProps.overflowSetSequence);\n      } // Take off the last sequence to calculate the parent ID\n\n\n      fullSequence.pop(); // Parent ID is the root if there aren't any more sequences\n\n      var parentID = fullSequence.length === 0 ? this.root.id : sequencesToID(fullSequence);\n      var matchesCurrWithoutOverflow = false;\n\n      if (this.currentKeytip.overflowSetSequence) {\n        var currKeytipIdWithoutOverflow = sequencesToID(this.currentKeytip.keySequences);\n        matchesCurrWithoutOverflow = currKeytipIdWithoutOverflow === parentID;\n      }\n\n      return matchesCurrWithoutOverflow || this.currentKeytip.id === parentID;\n    }\n\n    return false;\n  };\n\n  KeytipTree.prototype._getParentID = function (fullSequence) {\n    return fullSequence.length === 0 ? this.root.id : sequencesToID(fullSequence);\n  };\n\n  KeytipTree.prototype._getFullSequence = function (keytipProps) {\n    var fullSequence = __spreadArrays(keytipProps.keySequences);\n\n    if (keytipProps.overflowSetSequence) {\n      fullSequence = mergeOverflows(fullSequence, keytipProps.overflowSetSequence);\n    }\n\n    return fullSequence;\n  };\n\n  KeytipTree.prototype._getNodeSequence = function (node) {\n    var fullSequence = __spreadArrays(node.keySequences);\n\n    if (node.overflowSetSequence) {\n      fullSequence = mergeOverflows(fullSequence, node.overflowSetSequence);\n    }\n\n    return fullSequence[fullSequence.length - 1];\n  };\n\n  KeytipTree.prototype._createNode = function (id, parentId, children, keytipProps, persisted) {\n    var _this = this;\n\n    var keySequences = keytipProps.keySequences,\n        hasDynamicChildren = keytipProps.hasDynamicChildren,\n        overflowSetSequence = keytipProps.overflowSetSequence,\n        hasMenu = keytipProps.hasMenu,\n        onExecute = keytipProps.onExecute,\n        onReturn = keytipProps.onReturn,\n        disabled = keytipProps.disabled,\n        hasOverflowSubMenu = keytipProps.hasOverflowSubMenu;\n    var node = {\n      id: id,\n      keySequences: keySequences,\n      overflowSetSequence: overflowSetSequence,\n      parent: parentId,\n      children: children,\n      onExecute: onExecute,\n      onReturn: onReturn,\n      hasDynamicChildren: hasDynamicChildren,\n      hasMenu: hasMenu,\n      disabled: disabled,\n      persisted: persisted,\n      hasOverflowSubMenu: hasOverflowSubMenu\n    };\n    node.children = Object.keys(this.nodeMap).reduce(function (array, nodeMapKey) {\n      if (_this.nodeMap[nodeMapKey].parent === id) {\n        array.push(_this.nodeMap[nodeMapKey].id);\n      }\n\n      return array;\n    }, []);\n    return node;\n  };\n\n  KeytipTree.prototype._removeChildFromParents = function (parentID, childID) {\n    var parents = this.getNodes([parentID]);\n    parents.forEach(function (parent) {\n      var childIndex = parent.children.indexOf(childID);\n\n      if (childIndex >= 0) {\n        parent.children.splice(childIndex, 1);\n      }\n    });\n  };\n\n  return KeytipTree;\n}();\n\nexport { KeytipTree };","map":{"version":3,"sources":["components/KeytipLayer/KeytipTree.ts"],"names":[],"mappings":";AAAA,SAAS,IAAT,EAAe,4BAAf,EAA6C,MAA7C,QAA2D,iBAA3D;AACA,SAAS,sBAAT,EAAiC,cAAjC,EAAiD,aAAjD,QAAsE,qCAAtE;AACA,SAAS,YAAT,QAA6B,yCAA7B;AAIA;;AAEG;;AACH,IAAA,UAAA;AAAA;AAAA,YAAA;AAKE;;AAEG;AACH,WAAA,UAAA,GAAA;AALO,SAAA,OAAA,GAAiD,EAAjD,CAKP,CACE;;AACA,SAAK,IAAL,GAAY;AACV,MAAA,EAAE,EAAE,YADM;AAEV,MAAA,QAAQ,EAAE,EAFA;AAGV,MAAA,MAAM,EAAE,EAHE;AAIV,MAAA,YAAY,EAAE;AAJJ,KAAZ;AAMA,SAAK,OAAL,CAAa,KAAK,IAAL,CAAU,EAAvB,IAA6B,KAAK,IAAlC;AACD;AAED;;;;;;AAMG;;;AACI,EAAA,UAAA,CAAA,SAAA,CAAA,OAAA,GAAP,UAAe,WAAf,EAA0C,QAA1C,EAA4D,SAA5D,EAA+E;AAC7E,QAAM,YAAY,GAAG,KAAK,gBAAL,CAAsB,WAAtB,CAArB;;AACA,QAAM,MAAM,GAAG,aAAa,CAAC,YAAD,CAA5B,CAF6E,CAI7E;;AACA,IAAA,YAAY,CAAC,GAAb,GAL6E,CAM7E;;AACA,QAAM,QAAQ,GAAG,KAAK,YAAL,CAAkB,YAAlB,CAAjB,CAP6E,CAS7E;;;AACA,QAAM,IAAI,GAAG,KAAK,WAAL,CAAiB,MAAjB,EAAyB,QAAzB,EAAmC,EAAnC,EAAuC,WAAvC,EAAoD,SAApD,CAAb;;AACA,SAAK,OAAL,CAAa,QAAb,IAAyB,IAAzB,CAX6E,CAa7E;;AACA,QAAM,OAAO,GAAG,KAAK,QAAL,CAAc,CAAC,QAAD,CAAd,CAAhB;AACA,IAAA,OAAO,CAAC,OAAR,CAAgB,UAAA,MAAA,EAAM;AAAI,aAAA,MAAM,CAAC,QAAP,CAAgB,IAAhB,CAAA,MAAA,CAAA;AAA4B,KAAtD;AACD,GAhBM;AAkBP;;;;;AAKG;;;AACI,EAAA,UAAA,CAAA,SAAA,CAAA,UAAA,GAAP,UAAkB,WAAlB,EAA6C,QAA7C,EAA6D;AAC3D,QAAM,YAAY,GAAG,KAAK,gBAAL,CAAsB,WAAtB,CAArB;;AACA,QAAM,MAAM,GAAG,aAAa,CAAC,YAAD,CAA5B,CAF2D,CAI3D;;AACA,IAAA,YAAY,CAAC,GAAb,GAL2D,CAM3D;;AACA,QAAM,QAAQ,GAAG,KAAK,YAAL,CAAkB,YAAlB,CAAjB;;AACA,QAAM,IAAI,GAAG,KAAK,OAAL,CAAa,QAAb,CAAb;AACA,QAAM,UAAU,GAAG,IAAI,CAAC,MAAxB;;AACA,QAAI,IAAJ,EAAU;AACR;AACA,UAAI,UAAU,KAAK,QAAnB,EAA6B;AAC3B;AACA,aAAK,uBAAL,CAA6B,UAA7B,EAAyC,IAAI,CAAC,EAA9C;AACD;;AACD,UAAI,IAAI,CAAC,EAAL,KAAY,MAAhB,EAAwB;AACtB;AACA,YAAM,OAAO,GAAG,KAAK,QAAL,CAAc,CAAC,QAAD,CAAd,CAAhB;AACA,QAAA,OAAO,CAAC,OAAR,CAAgB,UAAA,MAAA,EAAM;AACpB,cAAM,KAAK,GAAG,MAAM,CAAC,QAAP,CAAgB,OAAhB,CAAwB,IAAI,CAAC,EAA7B,CAAd;AACA,UAAA,KAAK,IAAI,CAAT,GAAc,MAAM,CAAC,QAAP,CAAgB,KAAhB,IAAyB,MAAvC,GAAiD,MAAM,CAAC,QAAP,CAAgB,IAAhB,CAAqB,MAArB,CAAjD;AACD,SAHD;AAID,OAbO,CAeR;;;AACA,MAAA,IAAI,CAAC,EAAL,GAAU,MAAV;AACA,MAAA,IAAI,CAAC,YAAL,GAAoB,WAAW,CAAC,YAAhC;AACA,MAAA,IAAI,CAAC,mBAAL,GAA2B,WAAW,CAAC,mBAAvC;AACA,MAAA,IAAI,CAAC,SAAL,GAAiB,WAAW,CAAC,SAA7B;AACA,MAAA,IAAI,CAAC,QAAL,GAAgB,WAAW,CAAC,QAA5B;AACA,MAAA,IAAI,CAAC,kBAAL,GAA0B,WAAW,CAAC,kBAAtC;AACA,MAAA,IAAI,CAAC,OAAL,GAAe,WAAW,CAAC,OAA3B;AACA,MAAA,IAAI,CAAC,MAAL,GAAc,QAAd;AACA,MAAA,IAAI,CAAC,QAAL,GAAgB,WAAW,CAAC,QAA5B;AACD;AACF,GApCM;AAsCP;;;;AAIG;;;AACI,EAAA,UAAA,CAAA,SAAA,CAAA,UAAA,GAAP,UAAkB,WAAlB,EAA6C,QAA7C,EAA6D;AAC3D,QAAM,YAAY,GAAG,KAAK,gBAAL,CAAsB,WAAtB,CAArB;;AACA,QAAM,MAAM,GAAG,aAAa,CAAC,YAAD,CAA5B,CAF2D,CAI3D;;AACA,IAAA,YAAY,CAAC,GAAb,GAL2D,CAO3D;;AACA,SAAK,uBAAL,CAA6B,KAAK,YAAL,CAAkB,YAAlB,CAA7B,EAA8D,MAA9D;;AAEA,QAAI,KAAK,OAAL,CAAa,QAAb,CAAJ,EAA4B;AAC1B;AACA,aAAO,KAAK,OAAL,CAAa,QAAb,CAAP;AACD;AACF,GAdM;AAgBP;;;;;;;AAOG;;;AACI,EAAA,UAAA,CAAA,SAAA,CAAA,mBAAA,GAAP,UAA2B,WAA3B,EAAgD,aAAhD,EAA8E;AAA9E,QAAA,KAAA,GAAA,IAAA;;AACE,QAAM,aAAa,GAAG,KAAK,QAAL,CAAc,aAAa,CAAC,QAA5B,CAAtB;AACA,QAAM,aAAa,GAAG,aAAa,CAAC,MAAd,CAAqB,UAAC,IAAD,EAAsB;AAC/D,aAAO,KAAI,CAAC,gBAAL,CAAsB,IAAtB,MAAgC,WAAhC,IAA+C,CAAC,IAAI,CAAC,QAA5D;AACD,KAFqB,CAAtB,CAF4E,CAM5E;;AACA,QAAI,aAAa,CAAC,MAAd,KAAyB,CAA7B,EAAgC;AAC9B,aAAO,SAAP;AACD,KAT2E,CAW5E;AACA;;;AACA,QAAM,IAAI,GAAG,aAAa,CAAC,CAAD,CAA1B,CAb4E,CAe5E;;AACA,QAAI,aAAa,CAAC,MAAd,KAAyB,CAA7B,EAAgC;AAC9B,aAAO,IAAP;AACD,KAlB2E,CAoB5E;;;AACA,QAAM,YAAY,GAAG,IAAI,CAAC,YAA1B;AACA,QAAM,mBAAmB,GAAG,IAAI,CAAC,mBAAjC;AACA,QAAM,gBAAgB,GAAG,mBAAmB,GAAG,cAAc,CAAC,YAAD,EAAe,mBAAf,CAAjB,GAAuD,YAAnG;AACA,QAAM,oBAAoB,GAAG,sBAAsB,CAAC,gBAAD,CAAnD;AACA,QAAM,uBAAuB,GAAG,QAAQ,CAAC,gBAAT,CAA0B,oBAA1B,CAAhC,CAzB4E,CA2B5E;AACA;AACA;AACA;;AACA,QAAI,aAAa,CAAC,MAAd,GAAuB,uBAAuB,CAAC,MAAnD,EAA2D;AACzD,aAAO,IAAP;AACD,KAjC2E,CAmC5E;;;AACA,QAAM,aAAa,GAAG,KAAK,CAAC,IAAN,CAAW,uBAAX,EAAoC,SAApC,CAA8C,UAAC,OAAD,EAAqB;AACvF,aAAA,4BAA4B,CAAC,OAAD,CAA5B;AAAqC,KADjB,CAAtB;;AAGA,QAAI,aAAa,KAAK,CAAC,CAAvB,EAA0B;AACxB,aAAO,aAAa,CAAC,aAAD,CAApB;AACD,KAzC2E,CA2C5E;AACA;AACA;;;AACA,QAAM,YAAY,GAAG,aAAa,CAAC,IAAd,CAAmB,UAAA,YAAA,EAAY;AAAI,aAAA,YAAY,CAAZ,kBAAA;AAA+B,KAAlE,CAArB;AACA,WAAO,YAAY,IAAI,IAAvB;AACD,GAhDM;AAkDP;;;;;;;AAOG;;;AACI,EAAA,UAAA,CAAA,SAAA,CAAA,wBAAA,GAAP,UAAgC,WAAhC,EAAqD,aAArD,EAAmF;AAAnF,QAAA,KAAA,GAAA,IAAA,CAAmF,CACjF;;;AACA,QAAM,aAAa,GAAG,KAAK,QAAL,CAAc,aAAa,CAAC,QAA5B,CAAtB;AACA,WAAO,aAAa,CAAC,MAAd,CAAqB,UAAC,IAAD,EAAsB;AAChD,aAAO,KAAI,CAAC,gBAAL,CAAsB,IAAtB,EAA4B,OAA5B,CAAoC,WAApC,MAAqD,CAArD,IAA0D,CAAC,IAAI,CAAC,QAAvE;AACD,KAFM,CAAP;AAGD,GANM;AAQP;;;;;;AAMG;;;AACI,EAAA,UAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,IAAnB,EAAyC;AAAzC,QAAA,KAAA,GAAA,IAAA;;AACE,QAAI,CAAC,IAAL,EAAW;AACT,MAAA,IAAI,GAAG,KAAK,aAAZ;;AACA,UAAI,CAAC,IAAL,EAAW;AACT,eAAO,EAAP;AACD;AACF;;AACD,QAAM,QAAQ,GAAG,IAAI,CAAC,QAAtB;AACA,WAAO,MAAM,CAAC,IAAP,CAAY,KAAK,OAAjB,EAA0B,MAA1B,CAAiC,UAAC,KAAD,EAAkB,GAAlB,EAA6B;AACnE,UAAI,QAAQ,CAAC,OAAT,CAAiB,KAAI,CAAC,OAAL,CAAa,GAAb,EAAkB,EAAnC,KAA0C,CAA1C,IAA+C,CAAC,KAAI,CAAC,OAAL,CAAa,GAAb,EAAkB,SAAtE,EAAiF;AAC/E,QAAA,KAAK,CAAC,IAAN,CAAW,KAAI,CAAC,OAAL,CAAa,GAAb,EAAkB,EAA7B;AACD;;AACD,aAAO,KAAP;AACD,KALM,EAKJ,EALI,CAAP;AAMD,GAdM;AAgBP;;;;;AAKG;;;AACI,EAAA,UAAA,CAAA,SAAA,CAAA,QAAA,GAAP,UAAgB,GAAhB,EAA6B;AAA7B,QAAA,KAAA,GAAA,IAAA;;AACE,WAAO,MAAM,CAAC,IAAP,CAAY,KAAK,OAAjB,EAA0B,MAA1B,CAAiC,UAAC,KAAD,EAA2B,GAA3B,EAAsC;AAC5E,UAAI,GAAG,CAAC,OAAJ,CAAY,KAAI,CAAC,OAAL,CAAa,GAAb,EAAkB,EAA9B,KAAqC,CAAzC,EAA4C;AAC1C,QAAA,KAAK,CAAC,IAAN,CAAW,KAAI,CAAC,OAAL,CAAa,GAAb,CAAX;AACD;;AACD,aAAO,KAAP;AACD,KALM,EAKJ,EALI,CAAP;AAMD,GAPM;AASP;;;;;AAKG;;;AACI,EAAA,UAAA,CAAA,SAAA,CAAA,OAAA,GAAP,UAAe,EAAf,EAAyB;AACvB,QAAM,aAAa,GAAG,MAAM,CAAkB,KAAK,OAAvB,CAA5B;AACA,WAAO,IAAI,CAAC,aAAD,EAAgB,UAAC,IAAD,EAAsB;AAC/C,aAAO,IAAI,CAAC,EAAL,KAAY,EAAnB;AACD,KAFU,CAAX;AAGD,GALM;AAOP;;;;;AAKG;;;AACI,EAAA,UAAA,CAAA,SAAA,CAAA,qBAAA,GAAP,UAA6B,WAA7B,EAAsD;AACpD,QAAI,KAAK,aAAT,EAAwB;AACtB,UAAI,YAAY,GAAA,cAAA,CAAO,WAAW,CAAC,YAAnB,CAAhB;;AACA,UAAI,WAAW,CAAC,mBAAhB,EAAqC;AACnC,QAAA,YAAY,GAAG,cAAc,CAAC,YAAD,EAAe,WAAW,CAAC,mBAA3B,CAA7B;AACD,OAJqB,CAKtB;;;AACA,MAAA,YAAY,CAAC,GAAb,GANsB,CAOtB;;AACA,UAAM,QAAQ,GAAG,YAAY,CAAC,MAAb,KAAwB,CAAxB,GAA4B,KAAK,IAAL,CAAU,EAAtC,GAA2C,aAAa,CAAC,YAAD,CAAzE;AACA,UAAI,0BAA0B,GAAG,KAAjC;;AACA,UAAI,KAAK,aAAL,CAAmB,mBAAvB,EAA4C;AAC1C,YAAM,2BAA2B,GAAG,aAAa,CAAC,KAAK,aAAL,CAAmB,YAApB,CAAjD;AACA,QAAA,0BAA0B,GAAG,2BAA2B,KAAK,QAA7D;AACD;;AACD,aAAO,0BAA0B,IAAI,KAAK,aAAL,CAAmB,EAAnB,KAA0B,QAA/D;AACD;;AACD,WAAO,KAAP;AACD,GAlBM;;AAoBC,EAAA,UAAA,CAAA,SAAA,CAAA,YAAA,GAAR,UAAqB,YAArB,EAA2C;AACzC,WAAO,YAAY,CAAC,MAAb,KAAwB,CAAxB,GAA4B,KAAK,IAAL,CAAU,EAAtC,GAA2C,aAAa,CAAC,YAAD,CAA/D;AACD,GAFO;;AAIA,EAAA,UAAA,CAAA,SAAA,CAAA,gBAAA,GAAR,UAAyB,WAAzB,EAAkD;AAChD,QAAI,YAAY,GAAA,cAAA,CAAO,WAAW,CAAC,YAAnB,CAAhB;;AACA,QAAI,WAAW,CAAC,mBAAhB,EAAqC;AACnC,MAAA,YAAY,GAAG,cAAc,CAAC,YAAD,EAAe,WAAW,CAAC,mBAA3B,CAA7B;AACD;;AACD,WAAO,YAAP;AACD,GANO;;AAQA,EAAA,UAAA,CAAA,SAAA,CAAA,gBAAA,GAAR,UAAyB,IAAzB,EAA8C;AAC5C,QAAI,YAAY,GAAA,cAAA,CAAO,IAAI,CAAC,YAAZ,CAAhB;;AACA,QAAI,IAAI,CAAC,mBAAT,EAA8B;AAC5B,MAAA,YAAY,GAAG,cAAc,CAAC,YAAD,EAAe,IAAI,CAAC,mBAApB,CAA7B;AACD;;AACD,WAAO,YAAY,CAAC,YAAY,CAAC,MAAb,GAAsB,CAAvB,CAAnB;AACD,GANO;;AAQA,EAAA,UAAA,CAAA,SAAA,CAAA,WAAA,GAAR,UACE,EADF,EAEE,QAFF,EAGE,QAHF,EAIE,WAJF,EAKE,SALF,EAKqB;AALrB,QAAA,KAAA,GAAA,IAAA;;AAQI,QAAA,YAAY,GAQV,WAAW,CARD,YAAZ;AAAA,QACA,kBAAkB,GAOhB,WAAW,CAPK,kBADlB;AAAA,QAEA,mBAAmB,GAMjB,WAAW,CANM,mBAFnB;AAAA,QAGA,OAAO,GAKL,WAAW,CALN,OAHP;AAAA,QAIA,SAAS,GAIP,WAAW,CAJJ,SAJT;AAAA,QAKA,QAAQ,GAGN,WAAW,CAHL,QALR;AAAA,QAMA,QAAQ,GAEN,WAAW,CAFL,QANR;AAAA,QAOA,kBAAkB,GAChB,WAAW,CADK,kBAPlB;AASF,QAAM,IAAI,GAAG;AACX,MAAA,EAAE,EAAA,EADS;AAEX,MAAA,YAAY,EAAA,YAFD;AAGX,MAAA,mBAAmB,EAAA,mBAHR;AAIX,MAAA,MAAM,EAAE,QAJG;AAKX,MAAA,QAAQ,EAAA,QALG;AAMX,MAAA,SAAS,EAAA,SANE;AAOX,MAAA,QAAQ,EAAA,QAPG;AAQX,MAAA,kBAAkB,EAAA,kBARP;AASX,MAAA,OAAO,EAAA,OATI;AAUX,MAAA,QAAQ,EAAA,QAVG;AAWX,MAAA,SAAS,EAAA,SAXE;AAYX,MAAA,kBAAkB,EAAA;AAZP,KAAb;AAcA,IAAA,IAAI,CAAC,QAAL,GAAgB,MAAM,CAAC,IAAP,CAAY,KAAK,OAAjB,EAA0B,MAA1B,CAAiC,UAAC,KAAD,EAAkB,UAAlB,EAAoC;AACnF,UAAI,KAAI,CAAC,OAAL,CAAa,UAAb,EAAyB,MAAzB,KAAoC,EAAxC,EAA4C;AAC1C,QAAA,KAAK,CAAC,IAAN,CAAW,KAAI,CAAC,OAAL,CAAa,UAAb,EAAyB,EAApC;AACD;;AACD,aAAO,KAAP;AACD,KALe,EAKb,EALa,CAAhB;AAMA,WAAO,IAAP;AACD,GAtCO;;AAwCA,EAAA,UAAA,CAAA,SAAA,CAAA,uBAAA,GAAR,UAAgC,QAAhC,EAAkD,OAAlD,EAAiE;AAC/D,QAAM,OAAO,GAAG,KAAK,QAAL,CAAc,CAAC,QAAD,CAAd,CAAhB;AACA,IAAA,OAAO,CAAC,OAAR,CAAgB,UAAA,MAAA,EAAM;AACpB,UAAM,UAAU,GAAG,MAAM,CAAC,QAAP,CAAgB,OAAhB,CAAwB,OAAxB,CAAnB;;AACA,UAAI,UAAU,IAAI,CAAlB,EAAqB;AACnB,QAAA,MAAM,CAAC,QAAP,CAAgB,MAAhB,CAAuB,UAAvB,EAAmC,CAAnC;AACD;AACF,KALD;AAMD,GARO;;AASV,SAAA,UAAA;AAAC,CAzUD,EAAA","sourcesContent":["import { find, isElementVisibleAndNotHidden, values } from '../../Utilities';\nimport { ktpTargetFromSequences, mergeOverflows, sequencesToID } from '../../utilities/keytips/KeytipUtils';\nimport { KTP_LAYER_ID } from '../../utilities/keytips/KeytipConstants';\nimport type { IKeytipProps } from '../../Keytip';\nimport type { IKeytipTreeNode } from './IKeytipTreeNode';\n\n/**\n * This class is responsible for handling the parent/child relationships between keytips\n */\nexport class KeytipTree {\n  public currentKeytip?: IKeytipTreeNode;\n  public root: IKeytipTreeNode;\n  public nodeMap: { [nodeId: string]: IKeytipTreeNode } = {};\n\n  /**\n   * KeytipTree constructor\n   */\n  constructor() {\n    // Root has no keytipSequence\n    this.root = {\n      id: KTP_LAYER_ID,\n      children: [],\n      parent: '',\n      keySequences: [],\n    };\n    this.nodeMap[this.root.id] = this.root;\n  }\n\n  /**\n   * Add a keytip node to this KeytipTree\n   *\n   * @param keytipProps - Keytip to add to the Tree\n   * @param uniqueID - Unique ID for this keytip\n   * @param persisted - T/F if this keytip should be marked as persisted\n   */\n  public addNode(keytipProps: IKeytipProps, uniqueID: string, persisted?: boolean): void {\n    const fullSequence = this._getFullSequence(keytipProps);\n    const nodeID = sequencesToID(fullSequence);\n\n    // Take off the last item to calculate the parent sequence\n    fullSequence.pop();\n    // Parent ID is the root if there aren't any more sequences\n    const parentID = this._getParentID(fullSequence);\n\n    // Create node and add to map\n    const node = this._createNode(nodeID, parentID, [], keytipProps, persisted);\n    this.nodeMap[uniqueID] = node;\n\n    // Try to add self to parents children\n    const parents = this.getNodes([parentID]);\n    parents.forEach(parent => parent.children.push(nodeID));\n  }\n\n  /**\n   * Updates a node in the tree\n   *\n   * @param keytipProps - Keytip props to update\n   * @param uniqueID - Unique ID for this keytip\n   */\n  public updateNode(keytipProps: IKeytipProps, uniqueID: string): void {\n    const fullSequence = this._getFullSequence(keytipProps);\n    const nodeID = sequencesToID(fullSequence);\n\n    // Take off the last item to calculate the parent sequence\n    fullSequence.pop();\n    // Parent ID is the root if there aren't any more sequences\n    const parentID = this._getParentID(fullSequence);\n    const node = this.nodeMap[uniqueID];\n    const prevParent = node.parent;\n    if (node) {\n      // Fix parent nodes if needed\n      if (prevParent !== parentID) {\n        // If parent has changed, remove child from old parent\n        this._removeChildFromParents(prevParent, node.id);\n      }\n      if (node.id !== nodeID) {\n        // If the ID of the node has changed, update node's parent's array of children with new ID\n        const parents = this.getNodes([parentID]);\n        parents.forEach(parent => {\n          const index = parent.children.indexOf(node.id);\n          index >= 0 ? (parent.children[index] = nodeID) : parent.children.push(nodeID);\n        });\n      }\n\n      // Update values\n      node.id = nodeID;\n      node.keySequences = keytipProps.keySequences;\n      node.overflowSetSequence = keytipProps.overflowSetSequence;\n      node.onExecute = keytipProps.onExecute;\n      node.onReturn = keytipProps.onReturn;\n      node.hasDynamicChildren = keytipProps.hasDynamicChildren;\n      node.hasMenu = keytipProps.hasMenu;\n      node.parent = parentID;\n      node.disabled = keytipProps.disabled;\n    }\n  }\n\n  /**\n   * Removes a node from the KeytipTree\n   *\n   * @param sequence - full string of the node to remove\n   */\n  public removeNode(keytipProps: IKeytipProps, uniqueID: string): void {\n    const fullSequence = this._getFullSequence(keytipProps);\n    const nodeID = sequencesToID(fullSequence);\n\n    // Take off the last sequence to calculate the parent ID\n    fullSequence.pop();\n\n    // Parent ID is the root if there aren't any more sequences\n    this._removeChildFromParents(this._getParentID(fullSequence), nodeID);\n\n    if (this.nodeMap[uniqueID]) {\n      // Remove the node from the nodeMap\n      delete this.nodeMap[uniqueID];\n    }\n  }\n\n  /**\n   * Searches the currentKeytip's children to exactly match a sequence. Will not match disabled nodes but\n   * will match persisted nodes\n   *\n   * @param keySequence - string to match\n   * @param currentKeytip - The keytip whose children will try to match\n   * @returns The node that exactly matched the keySequence, or undefined if none matched\n   */\n  public getExactMatchedNode(keySequence: string, currentKeytip: IKeytipTreeNode): IKeytipTreeNode | undefined {\n    const possibleNodes = this.getNodes(currentKeytip.children);\n    const matchingNodes = possibleNodes.filter((node: IKeytipTreeNode) => {\n      return this._getNodeSequence(node) === keySequence && !node.disabled;\n    });\n\n    // If we found no nodes, we are done\n    if (matchingNodes.length === 0) {\n      return undefined;\n    }\n\n    // Since the matching nodes all have the same key sequence,\n    // Grab the first one build the correct selector\n    const node = matchingNodes[0];\n\n    // If we have exactly one node, return it\n    if (matchingNodes.length === 1) {\n      return node;\n    }\n\n    // Get the potential target elements based on a selector from the sequences\n    const keySequences = node.keySequences;\n    const overflowSetSequence = node.overflowSetSequence;\n    const fullKeySequences = overflowSetSequence ? mergeOverflows(keySequences, overflowSetSequence) : keySequences;\n    const keytipTargetSelector = ktpTargetFromSequences(fullKeySequences);\n    const potentialTargetElements = document.querySelectorAll(keytipTargetSelector);\n\n    // If we have less nodes than the potential target elements,\n    // we won't be able to map element to node, return the first node.\n    // Note, the number of nodes could be more than the number of potential\n    // target elements, if an OverflowSet is involved\n    if (matchingNodes.length < potentialTargetElements.length) {\n      return node;\n    }\n\n    // Attempt to find the node that corresponds to the first visible/non-hidden element\n    const matchingIndex = Array.from(potentialTargetElements).findIndex((element: HTMLElement) =>\n      isElementVisibleAndNotHidden(element),\n    );\n    if (matchingIndex !== -1) {\n      return matchingNodes[matchingIndex];\n    }\n\n    // We did not find any visible elements associated with any of the nodes.\n    // We may be dealing with a keytip that is a submenu in an OverflowSet.\n    // Worst case, fall back to the first node returned\n    const overflowNode = matchingNodes.find(matchingNode => matchingNode.hasOverflowSubMenu);\n    return overflowNode || node;\n  }\n\n  /**\n   * Searches the currentKeytip's children to find nodes that start with the given sequence. Will not match\n   * disabled nodes but will match persisted nodes\n   *\n   * @param keySequence - string to partially match\n   * @param currentKeytip - The keytip whose children will try to partially match\n   * @returns List of tree nodes that partially match the given sequence\n   */\n  public getPartiallyMatchedNodes(keySequence: string, currentKeytip: IKeytipTreeNode): IKeytipTreeNode[] {\n    // Get children that are persisted\n    const possibleNodes = this.getNodes(currentKeytip.children);\n    return possibleNodes.filter((node: IKeytipTreeNode) => {\n      return this._getNodeSequence(node).indexOf(keySequence) === 0 && !node.disabled;\n    });\n  }\n\n  /**\n   * Get the non-persisted children of the give node\n   * If no node is given, will use the 'currentKeytip'\n   *\n   * @param node - Node to get the children for\n   * @returns List of node IDs that are the children of the node\n   */\n  public getChildren(node?: IKeytipTreeNode): string[] {\n    if (!node) {\n      node = this.currentKeytip;\n      if (!node) {\n        return [];\n      }\n    }\n    const children = node.children;\n    return Object.keys(this.nodeMap).reduce((nodes: string[], key: string): string[] => {\n      if (children.indexOf(this.nodeMap[key].id) >= 0 && !this.nodeMap[key].persisted) {\n        nodes.push(this.nodeMap[key].id);\n      }\n      return nodes;\n    }, []);\n  }\n\n  /**\n   * Gets all nodes from their IDs\n   *\n   * @param ids - List of keytip IDs\n   * @returns Array of nodes that match the given IDs, can be empty\n   */\n  public getNodes(ids: string[]): IKeytipTreeNode[] {\n    return Object.keys(this.nodeMap).reduce((nodes: IKeytipTreeNode[], key: string): IKeytipTreeNode[] => {\n      if (ids.indexOf(this.nodeMap[key].id) >= 0) {\n        nodes.push(this.nodeMap[key]);\n      }\n      return nodes;\n    }, []);\n  }\n\n  /**\n   * Gets a single node from its ID\n   *\n   * @param id - ID of the node to get\n   * @returns Node with the given ID, if found\n   */\n  public getNode(id: string): IKeytipTreeNode | undefined {\n    const nodeMapValues = values<IKeytipTreeNode>(this.nodeMap);\n    return find(nodeMapValues, (node: IKeytipTreeNode): boolean => {\n      return node.id === id;\n    });\n  }\n\n  /**\n   * Tests if the currentKeytip in this.keytipTree is the parent of 'keytipProps'\n   *\n   * @param keytipProps - Keytip to test the parent for\n   * @returns T/F if the currentKeytip is this keytipProps' parent\n   */\n  public isCurrentKeytipParent(keytipProps: IKeytipProps): boolean {\n    if (this.currentKeytip) {\n      let fullSequence = [...keytipProps.keySequences];\n      if (keytipProps.overflowSetSequence) {\n        fullSequence = mergeOverflows(fullSequence, keytipProps.overflowSetSequence);\n      }\n      // Take off the last sequence to calculate the parent ID\n      fullSequence.pop();\n      // Parent ID is the root if there aren't any more sequences\n      const parentID = fullSequence.length === 0 ? this.root.id : sequencesToID(fullSequence);\n      let matchesCurrWithoutOverflow = false;\n      if (this.currentKeytip.overflowSetSequence) {\n        const currKeytipIdWithoutOverflow = sequencesToID(this.currentKeytip.keySequences);\n        matchesCurrWithoutOverflow = currKeytipIdWithoutOverflow === parentID;\n      }\n      return matchesCurrWithoutOverflow || this.currentKeytip.id === parentID;\n    }\n    return false;\n  }\n\n  private _getParentID(fullSequence: string[]): string {\n    return fullSequence.length === 0 ? this.root.id : sequencesToID(fullSequence);\n  }\n\n  private _getFullSequence(keytipProps: IKeytipProps): string[] {\n    let fullSequence = [...keytipProps.keySequences];\n    if (keytipProps.overflowSetSequence) {\n      fullSequence = mergeOverflows(fullSequence, keytipProps.overflowSetSequence);\n    }\n    return fullSequence;\n  }\n\n  private _getNodeSequence(node: IKeytipTreeNode): string {\n    let fullSequence = [...node.keySequences];\n    if (node.overflowSetSequence) {\n      fullSequence = mergeOverflows(fullSequence, node.overflowSetSequence);\n    }\n    return fullSequence[fullSequence.length - 1];\n  }\n\n  private _createNode(\n    id: string,\n    parentId: string,\n    children: string[],\n    keytipProps: IKeytipProps,\n    persisted?: boolean,\n  ): IKeytipTreeNode {\n    const {\n      keySequences,\n      hasDynamicChildren,\n      overflowSetSequence,\n      hasMenu,\n      onExecute,\n      onReturn,\n      disabled,\n      hasOverflowSubMenu,\n    } = keytipProps;\n    const node = {\n      id,\n      keySequences,\n      overflowSetSequence,\n      parent: parentId,\n      children,\n      onExecute,\n      onReturn,\n      hasDynamicChildren,\n      hasMenu,\n      disabled,\n      persisted,\n      hasOverflowSubMenu,\n    };\n    node.children = Object.keys(this.nodeMap).reduce((array: string[], nodeMapKey: string): string[] => {\n      if (this.nodeMap[nodeMapKey].parent === id) {\n        array.push(this.nodeMap[nodeMapKey].id);\n      }\n      return array;\n    }, []);\n    return node;\n  }\n\n  private _removeChildFromParents(parentID: string, childID: string): void {\n    const parents = this.getNodes([parentID]);\n    parents.forEach(parent => {\n      const childIndex = parent.children.indexOf(childID);\n      if (childIndex >= 0) {\n        parent.children.splice(childIndex, 1);\n      }\n    });\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}